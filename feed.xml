<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://rinehartj.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://rinehartj.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-24T04:02:15+00:00</updated><id>https://rinehartj.github.io/feed.xml</id><title type="html">Jason Rinehart’s Portfolio</title><subtitle>A collection of projects and blog posts about electronics and computers. </subtitle><entry><title type="html">Raspberry Pi Pico as a hardware ISP</title><link href="https://rinehartj.github.io/blog/2025/hardwareISP/" rel="alternate" type="text/html" title="Raspberry Pi Pico as a hardware ISP"/><published>2025-02-23T00:00:00+00:00</published><updated>2025-02-23T00:00:00+00:00</updated><id>https://rinehartj.github.io/blog/2025/hardwareISP</id><content type="html" xml:base="https://rinehartj.github.io/blog/2025/hardwareISP/"><![CDATA[<div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardwareISP/isp-480.webp 480w,/assets/img/hardwareISP/isp-800.webp 800w,/assets/img/hardwareISP/isp-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardwareISP/isp.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h4 id="this-project-began-when-i-was-looking-for-proof-that-my-arduino-nano-could-be-brought-back-to-life">This project began when I was looking for proof that my Arduino Nano could be brought back to life.</h4> <h2 id="introduction">Introduction</h2> <p>Why purchase the genuine version of an open source hardware device when clones can be purchased for less? I asked myself this question a few years ago and decided to pick up some Arduino Nano clones from AliExpress. Once they arrived, I remember them to be well-soldered and free of noticeable imperfections. As I experimented with the boards, I learned the quirks of these specific boards thoroughly.</p> <h2 id="terms">Terms</h2> <p>The term “<strong>open source</strong>” describes source code or design documents that are free to access and redistribute<d-cite key="enwiki:1276146904"></d-cite>. <strong>Arduino</strong> is an open source platform and community centered around making complex electronics and digital technologies available to all<d-cite key="arduinoAboutArduino"></d-cite>. The Arduino Integrated Development Environment (IDE) is a software for writing code and programming Arduino boards, including the Arduino Nano. This article mentions the Arduino Nano, a compact microcontroller board that hosts the ATMega328P microcontroller.</p> <h2 id="findings">Findings</h2> <p>At first, code was not uploading to any of the Arduino Nano boards. The Arduino IDE would get stuck on “Uploading…” or similar. Thankfully, communication issues between the board and software are thoroughly documented online. I found that two changes were important to getting my version of the Nano clone working:</p> <p>First, the <code class="language-plaintext highlighter-rouge">CH340G</code> USB to UART converter chip on the clones required downloading and installing a driver. The name of the file was <code class="language-plaintext highlighter-rouge">CH341SER.exe</code> which can be downloaded <a href="http://www.wch.cn/download/CH341SER_EXE.html">here</a>.</p> <p>Furthermore, I needed to make the following setting in Arduino IDE:</p> <ul> <li>Processor: <strong>ATMega328P (Old Bootloader)</strong></li> </ul> <p>There appears to be two bootloaders for the <code class="language-plaintext highlighter-rouge">ATMega328P</code> chip, titled by Arduino IDE as “old” and “new”. My Nano only worked when setting the Arduino IDE to “Old Bootloader” so I assume it had the old bootloader installed. Later in this article, I discuss how I flashed the “new” bootloader to the chip using a Raspberry Pi Pico microcontroller board.</p> <p>Finally, I made sure to use a USB cable that supported <strong>data and power</strong> (as opposed to <strong>power only</strong>). I did this by listening for the USB insertion sound when I plugged in the cable and checking the device manager utility for a new listing.</p> <h2 id="how-i-accidentally-erased-the-bootloader">How I accidentally erased the bootloader</h2> <div class="row mt-3"> <div class="col-sm-4 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardwareISP/MarlinOldFirmware-480.webp 480w,/assets/img/hardwareISP/MarlinOldFirmware-800.webp 800w,/assets/img/hardwareISP/MarlinOldFirmware-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardwareISP/MarlinOldFirmware.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardwareISP/MarlinNewFirmware-480.webp 480w,/assets/img/hardwareISP/MarlinNewFirmware-800.webp 800w,/assets/img/hardwareISP/MarlinNewFirmware-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardwareISP/MarlinNewFirmware.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-8 mt-3 mt-md-0"> Earlier this year, I updated the firmware for my Ender 3 Pro 3D printer to access a new feature called "Z-Babystep". However, on older Ender 3 Pro versions using the 8-bit "Melzi" motherboard, bootloaders were sometimes not included from the factory, including mine. I flashed a bootloader myself using <a href="https://letsprint3d.net/guide-how-to-flash-a-bootloader-on-melzi-boards/">this online guide</a>. After wiring the SPI headers of my Arduino Nano and Melzi motherboard together, I uploaded the "Arduino as ISP" sketch to the Nano using Arduino IDE. Then, I set "Board" to "Sanguino" and used the "Burn Bootloader" function. At this point, I was able to upload Marlin firmware without issue. </div> </div> <p>However, this process seemed to have wiped the bootloader from my Arduino Nano, as it was no longer accepting new sketches. Arduino IDE was hanging at “Uploading Sketch”.</p> <h2 id="flashing-the-new-bootloader">Flashing the new bootloader</h2> <p>To flash an ATMega chip with a corrupted or erased bootloader such as mine, an <strong>In-System Programmer</strong> (ISP) is needed. The easiest path forward would be to use <em>another Arduino</em> since both devices would operate at the same logic level (5V). I had none on hand so I chose to use a Raspberry Pi Pico which operates at 3.3V. I needed to be careful that logic levels would not saturate.</p> <p>According to the datasheet, the maximum safe DIO voltage of the RP2040 is <code class="language-plaintext highlighter-rouge">IOVDD + 0.5V</code>. I measured the IOVDD pin using a multimeter and found it to be 3.27V, so in my case, the maximum safe DIO voltage was 3.77V. It was possible that level shifters were not needed between the Arduino Nano and Pi Pico, as long as the Arduino Nano could operate at 3.77V reliably.</p> <h3 id="flashing-steps">Flashing Steps</h3> <ol> <li>I downloaded the Adafruit AVR programmer repository <a href="https://github.com/adafruit/Adafruit_CircuitPython_AVRprog/tree/main">here</a>.</li> <li>I held the <code class="language-plaintext highlighter-rouge">BOOTSEL</code> button on the Pi Pico while plugging it in over a data-capable USB cable. I then let go of the button and uploaded the <a href="https://circuitpython.org/board/raspberry_pi_pico/">CircuitPython .uf2 file</a> to the mounted drive.</li> <li>I connected to the Pi Pico using the online CircuitPython IDE available <a href="https://code.circuitpython.org/">here</a> to upload code and libraries.</li> </ol> <p>When all was finished, the file structure of the Pi Pico root directory looked like this:</p> <div class="col-sm mt-3 mt-md-0 w-50"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/hardwareISP/filesystem-480.webp 480w,/assets/img/hardwareISP/filesystem-800.webp 800w,/assets/img/hardwareISP/filesystem-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/hardwareISP/filesystem.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>I then made the following connections between the Arduino Nano and Pi Pico:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arduino Clk &lt;&gt; Pico GP18
Arduino MOSI &lt;&gt; Pico GP19
Arduino MISO &lt;&gt; Pico GP16
Arduino RST &lt;&gt; Pico GP10
</code></pre></div></div> <p>and set these accordingly in Code.py as seen below:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spi</span> <span class="o">=</span> <span class="n">busio</span><span class="p">.</span><span class="nc">SPI</span><span class="p">(</span><span class="n">clock</span><span class="o">=</span><span class="n">board</span><span class="p">.</span><span class="n">GP18</span><span class="p">,</span> <span class="n">MOSI</span><span class="o">=</span><span class="n">board</span><span class="p">.</span><span class="n">GP19</span><span class="p">,</span> <span class="n">MISO</span><span class="o">=</span><span class="n">board</span><span class="p">.</span><span class="n">GP16</span><span class="p">)</span>
<span class="n">avrprog</span> <span class="o">=</span> <span class="n">adafruit_avrprog</span><span class="p">.</span><span class="nc">AVRprog</span><span class="p">()</span>
<span class="n">avrprog</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">board</span><span class="p">.</span><span class="n">GP10</span><span class="p">)</span>
</code></pre></div></div> <p>I ran the code, and to my surprise the chip was flashed in less than a second. At first I was worried, because the program skipped almost all of the sectors. However, at the very end, code was uploaded and verified, which I presume to be the bootloader. After a round of testing, the Arduino was then able to accept code via the Arduino IDE. Since I flashed the <em>new</em> bootloader, I could now select <code class="language-plaintext highlighter-rouge">Processor: ATmega328P</code> instead of the old bootloader option.</p> <details><summary>Click to expand console output</summary> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ready to GO, type 'G' here to start&gt; G
Found signature: ['0x1e', '0x95', '0xf']
Found ATmega328p
Programming flash from file
Erasing chip....
Programming page $0000...skipping
Programming page $0080...skipping
Programming page $0100...skipping
Programming page $0180...skipping
Programming page $0200...skipping
Programming page $0280...skipping

(230 more lines...)

Programming page $7880...skipping
Programming page $7900...skipping
Programming page $7980...skipping
Programming page $7A00...skipping
Programming page $7A80...skipping
Programming page $7B00...skipping
Programming page $7B80...skipping
Programming page $7C00...skipping
Programming page $7C80...skipping
Programming page $7D00...skipping
Programming page $7D80...skipping
Programming page $7E00...Verifying page @ $7E00
Programming page $7E80...Verifying page @ $7E80
Programming page $7F00...Verifying page @ $7F00
Programming page $7F80...Verifying page @ $7F80
Done!

Code done running.
</code></pre></div></div> </details> <h2 id="conclusion">Conclusion</h2> <p>According to <a href="https://www.reddit.com/r/arduino/comments/10o64v2/comment/j6g53h1/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">this reddit post</a>, new Nano clones are being shipped with the new bootloader. This procedure would likely work for anyone who would like to update their Nano bootloader if they had an old board. Considering the inexpensive price tag of the Arduino Nano compared to other microcontroller boards, I suspect most people with corrupted bootloaders would opt for a replacement. I am glad I chose the more challenging path of flashing a bootloader which extended the life of my trusty Arduino.</p> ]]></content><author><name></name></author><category term="hardware,"/><category term="firmware"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Website Updates</title><link href="https://rinehartj.github.io/blog/2025/webupdates/" rel="alternate" type="text/html" title="Website Updates"/><published>2025-02-11T00:00:00+00:00</published><updated>2025-02-11T00:00:00+00:00</updated><id>https://rinehartj.github.io/blog/2025/webupdates</id><content type="html" xml:base="https://rinehartj.github.io/blog/2025/webupdates/"><![CDATA[<p>2/10/2025: <em>Added drafts folder for work-in-progress posts</em>. For Jekyll to handle drafts properly, two changes were necessary. First, I created a <code class="language-plaintext highlighter-rouge">_drafts</code> folder in the root directory. Second, I added this line to <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">command</span>: bundle <span class="nb">exec </span>jekyll serve <span class="nt">--host</span> 0.0.0.0 <span class="nt">--port</span> 8080 <span class="nt">--livereload</span> <span class="nt">--drafts</span> <span class="nt">--watch</span> <span class="nt">--force_polling</span> <span class="nt">--verbose</span> <span class="nt">--incremental</span>
</code></pre></div></div> <p>I then rebuilt the Docker container which hosts the local Jekyll server using <code class="language-plaintext highlighter-rouge">docker compose up --build</code>. The action of adding this new line appeared to override the Jekyll startup shell script, <code class="language-plaintext highlighter-rouge">entry_point.sh</code>.</p> <p>I arrived to this solution after several failed attempts at modifying <code class="language-plaintext highlighter-rouge">/bin/entry_point.sh</code> and expecting to see an immediate response upon restarting the server. It was unclear and not mentioned in articles I read that the Docker container needed to be re-built for any changes, whether to <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> or <code class="language-plaintext highlighter-rouge">/bin/entry_point.sh</code>, to take place.</p> <p>More testing revealed that modifying the <code class="language-plaintext highlighter-rouge">start_jekyll()</code> function in <code class="language-plaintext highlighter-rouge">/bin/entry_point.sh</code> worked for some flags, but not others. I noticed that while adding <code class="language-plaintext highlighter-rouge">--drafts</code> flag to this file seemed to work, adding <code class="language-plaintext highlighter-rouge">--incremental</code> had no effect. Instead, I reversed changes made to <code class="language-plaintext highlighter-rouge">/bin/entry_point.sh</code> and instead added that parameter to the newly created command specified in <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>. This time, the server responded to every flag I specified.</p> <p>This will allow drafts to be published only when moved out of the <code class="language-plaintext highlighter-rouge">_drafts</code> folder and into the <code class="language-plaintext highlighter-rouge">_posts</code> folder.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[2/10/2025: Added drafts folder for work-in-progress posts. For Jekyll to handle drafts properly, two changes were necessary. First, I created a _drafts folder in the root directory. Second, I added this line to docker-compose.yml:]]></summary></entry></feed>